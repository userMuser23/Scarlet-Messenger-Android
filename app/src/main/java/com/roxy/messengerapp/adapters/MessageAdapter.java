package com.roxy.messengerapp.adapters;import android.app.AlertDialog;import android.content.Context;import android.content.DialogInterface;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;import android.widget.Toast;import androidx.annotation.NonNull;import androidx.recyclerview.widget.RecyclerView;import com.bumptech.glide.Glide;import com.google.android.gms.tasks.OnCompleteListener;import com.google.android.gms.tasks.Task;import com.google.firebase.auth.FirebaseAuth;import com.google.firebase.auth.FirebaseUser;import com.google.firebase.database.DatabaseReference;import com.google.firebase.database.FirebaseDatabase;import com.roxy.messengerapp.R;import com.roxy.messengerapp.entities.Chat;import java.util.List;import de.hdodenhof.circleimageview.CircleImageView;public class MessageAdapter extends RecyclerView.Adapter<MessageAdapter.ViewHolder> {    // Константы для определения типа сообщения    public static final int MSG_TYPE_LEFT = 0;    public static final int MSG_TYPE_RIGHT = 1;    private Context mContext;    private List<Chat> mChat;    private String imageurl; // Ссылка на аватарку собеседника    FirebaseUser fuser;    // Конструктор: принимаем контекст, список сообщений и фото собеседника    public MessageAdapter(Context mContext, List<Chat> mChat, String imageurl){        this.mChat = mChat;        this.mContext = mContext;        this.imageurl = imageurl;    }    // 1. Самый важный метод! Определяет, чей макет использовать    @Override    public int getItemViewType(int position) {        fuser = FirebaseAuth.getInstance().getCurrentUser();        // Если отправитель сообщения == Я (текущий юзер) -> Тип ПРАВЫЙ        if (mChat.get(position).getSender().equals(fuser.getUid())){            return MSG_TYPE_RIGHT;        } else {            // Иначе -> Тип ЛЕВЫЙ            return MSG_TYPE_LEFT;        }    }    // 2. Создаем "формочку" (ViewHolder)    @NonNull    @Override    public MessageAdapter.ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {        // viewType прилетает из метода выше        if (viewType == MSG_TYPE_RIGHT) {            View view = LayoutInflater.from(mContext).inflate(R.layout.chat_item_right, parent, false);            return new ViewHolder(view);        } else {            View view = LayoutInflater.from(mContext).inflate(R.layout.chat_item_left, parent, false);            return new ViewHolder(view);        }    }    // 3. Заполняем данными    @Override    public void onBindViewHolder(@NonNull MessageAdapter.ViewHolder holder, int position) {        Chat chat = mChat.get(position);        holder.show_message.setText(chat.getMessage());        holder.time_tv.setText(chat.getTime());        // Проверяем, есть ли вообще место под картинку (вдруг это правое сообщение)        if (holder.profile_image != null) {            if (imageurl.equals("default")) {                holder.profile_image.setImageResource(R.mipmap.ic_launcher);            } else {                Glide.with(mContext).load(imageurl).into(holder.profile_image);            }        }        holder.itemView.setOnLongClickListener(new View.OnLongClickListener() {            @Override            public boolean onLongClick(View v) {                // Проверяем: можно удалять только СВОИ сообщения                if (mChat.get(position).getSender().equals(fuser.getUid())) {                    deleteMessage(position);                } else {                    // Чужие сообщения удалять нельзя (как в WhatsApp)                    Toast.makeText(mContext, "Нельзя удалить чужое сообщение", Toast.LENGTH_SHORT).show();                }                return true;            }        });    }    @Override    public int getItemCount() {        return mChat.size();    }    // Класс-хранилище ссылок на элементы UI    public class ViewHolder extends RecyclerView.ViewHolder{        public TextView show_message;        public CircleImageView profile_image;        public TextView time_tv;        public ViewHolder(View itemView) {            super(itemView);            show_message = itemView.findViewById(R.id.show_message);            profile_image = itemView.findViewById(R.id.profile_image);            time_tv = itemView.findViewById(R.id.time_tv);        }    }    private void deleteMessage(int position) {        AlertDialog.Builder builder = new AlertDialog.Builder(mContext);        builder.setTitle("Удаление сообщения");        builder.setMessage("Вы точно хотите удалить это сообщение?");        // Кнопка ДА        builder.setPositiveButton("Удалить", new DialogInterface.OnClickListener() {            @Override            public void onClick(DialogInterface dialog, int which) {                // 1. Получаем ID                String msgId = mChat.get(position).getId();                DatabaseReference dbRef = FirebaseDatabase.getInstance().getReference("Chats").child(msgId);                // 2. Удаляем с проверкой успеха (код из второго варианта)                dbRef.removeValue().addOnCompleteListener(new OnCompleteListener<Void>() {                    @Override                    public void onComplete(@NonNull Task<Void> task) {                        if (task.isSuccessful()) {                            Toast.makeText(mContext, "Сообщение удалено", Toast.LENGTH_SHORT).show();                        } else {                            Toast.makeText(mContext, "Ошибка удаления", Toast.LENGTH_SHORT).show();                        }                    }                });            }        });        // Кнопка НЕТ        builder.setNegativeButton("Отмена", new DialogInterface.OnClickListener() {            @Override            public void onClick(DialogInterface dialog, int which) {                dialog.dismiss();            }        });        builder.create().show();    }}